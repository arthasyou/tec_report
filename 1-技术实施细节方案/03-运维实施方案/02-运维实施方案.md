# 自动化开发环境部署运维方案

这个运维方案专注于自动化开发环境部署，提供了完整的CI/CD流水线、多环境管理、Nginx网关和自动化部署能力，确保开发团队能够快速、可靠地部署和管理应用服务。通过Nginx网关的统一入口，实现了流量管理、安全防护和性能优化的全面覆盖。

## 一、自动化部署架构设计

### 1.1 核心目标

**主要目标：** 构建一套完全自动化的开发环境部署体系，实现从代码提交到环境就绪的全流程自动化，支持多环境快速部署和版本管理。

#### 核心能力
- **一键环境部署：** 开发、测试、预发、生产环境一键部署
- **版本自动管理：** 自动构建、标签管理、版本回滚
- **环境隔离：** 多套环境互不干扰，独立配置管理
- **快速扩容：** 支持水平扩容，负载均衡自动配置
- **故障自愈：** 健康检查、自动重启、服务降级

### 1.2 技术架构

#### 自动化部署流水线
```
Automated Deployment Pipeline
├── 代码管理层
│   ├── GitLab CE (源码管理)
│   ├── 分支策略 (GitFlow)
│   └── 代码质量检查
├── 构建层
│   ├── GitLab CI/CD
│   ├── Docker Build
│   └── 镜像Registry
├── 部署层
│   ├── Ansible (配置管理)
│   ├── Docker Compose (容器编排)
│   └── Nginx (反向代理/负载均衡)
├── 网关层
│   ├── Nginx Gateway (统一入口)
│   ├── 负载均衡 (多服务分发)
│   ├── SSL终结 (HTTPS处理)
│   └── 限流熔断 (安全防护)
├── 监控层
│   ├── 健康检查
│   ├── 日志收集
│   └── 性能监控
└── 管理层
    ├── 环境管理
    ├── 版本控制
    └── 回滚机制
```

### 1.3 环境分层设计

#### 环境架构
```yaml
# 环境分层架构
environments:
  dev:
    purpose: "开发环境 - 开发人员日常开发"
    trigger: "push to develop branch"
    resources: "最小配置，快速部署"
    
  test:
    purpose: "测试环境 - 功能测试验证"
    trigger: "merge request to main"
    resources: "标准配置，稳定测试"
    
  staging:
    purpose: "预发环境 - 生产前验证"
    trigger: "tag release"  
    resources: "生产配置，完整验证"
    
  prod:
    purpose: "生产环境 - 正式对外服务"
    trigger: "manual deployment"
    resources: "高可用配置，性能优化"
```

## 二、GitLab CI/CD自动化配置

### 2.1 分支策略与触发规则

#### GitFlow分支模型
```yaml
# 分支策略配置
branches:
  main:
    protection: true
    auto_deploy: staging
    merge_requests: required
    
  develop:
    auto_deploy: dev
    merge_requests: optional
    
  feature/*:
    auto_deploy: dev (optional)
    cleanup: auto (after merge)
    
  release/*:
    auto_deploy: test
    protection: true
    
  hotfix/*:
    auto_deploy: [test, staging]
    fast_track: true
```

### 2.2 完整CI/CD配置模板

#### 后端服务自动化配置
```yaml
# .gitlab-ci.yml for Backend Service
stages:
  - validate
  - test
  - build
  - deploy-dev
  - deploy-test
  - deploy-staging
  - deploy-prod

variables:
  # Docker配置
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  
  # 环境配置
  DEV_HOST: "dev.company.com"
  TEST_HOST: "test.company.com"
  STAGING_HOST: "staging.company.com"
  PROD_HOST: "company.com"

# 代码质量检查
code-quality:
  stage: validate
  image: gradle:8-jdk17
  script:
    - gradle checkstyleMain
    - gradle pmdMain
    - gradle spotbugsMain
  artifacts:
    reports:
      codequality: build/reports/codequality.json
  only:
    - merge_requests
    - main
    - develop

# 单元测试
unit-test:
  stage: test
  image: gradle:8-jdk17
  services:
    - name: mysql:8.0
      alias: mysql
      variables:
        MYSQL_ROOT_PASSWORD: test_password
        MYSQL_DATABASE: test_db
    - name: redis:7-alpine
      alias: redis
  variables:
    SPRING_PROFILES_ACTIVE: test
    DB_HOST: mysql
    REDIS_HOST: redis
  script:
    - gradle test --no-daemon
    - gradle jacocoTestReport
  coverage: '/Total.*?([0-9]{1,3})%/'
  artifacts:
    reports:
      junit: build/test-results/test/**/TEST-*.xml
      coverage_report:
        coverage_format: cobertura
        path: build/reports/jacoco/test/cobertura.xml
  only:
    - merge_requests
    - main
    - develop

# 构建Docker镜像
build-image:
  stage: build
  image: docker:24
  services:
    - docker:24-dind
  before_script:
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    # 构建应用
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE:latest
    
    # 推送镜像
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - docker push $CI_REGISTRY_IMAGE:latest
    
    # 创建版本标签
    - |
      if [ "$CI_COMMIT_REF_NAME" == "main" ]; then
        docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE:stable
        docker push $CI_REGISTRY_IMAGE:stable
      fi
  only:
    - main
    - develop
    - /^release\/.*$/
    - tags

# 开发环境部署
deploy-dev:
  stage: deploy-dev
  image: alpine:latest
  before_script:
    - apk add --no-cache curl ansible openssh
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
  script:
    - |
      ansible-playbook -i inventory/dev.yml playbooks/deploy.yml \
        --extra-vars "image_tag=$CI_COMMIT_SHA environment=dev" \
        --extra-vars "service_name=$CI_PROJECT_NAME"
  environment:
    name: development
    url: https://$DEV_HOST
    on_stop: stop-dev
  only:
    - develop
  when: on_success

# 测试环境部署
deploy-test:
  stage: deploy-test
  image: alpine:latest
  before_script:
    - apk add --no-cache curl ansible openssh
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
  script:
    - |
      ansible-playbook -i inventory/test.yml playbooks/deploy.yml \
        --extra-vars "image_tag=$CI_COMMIT_SHA environment=test" \
        --extra-vars "service_name=$CI_PROJECT_NAME"
    # 自动化测试
    - ansible-playbook -i inventory/test.yml playbooks/smoke-test.yml
  environment:
    name: testing
    url: https://$TEST_HOST
  only:
    - main
    - /^release\/.*$/
  when: on_success

# 预发环境部署  
deploy-staging:
  stage: deploy-staging
  image: alpine:latest
  before_script:
    - apk add --no-cache curl ansible openssh
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
  script:
    - |
      ansible-playbook -i inventory/staging.yml playbooks/deploy.yml \
        --extra-vars "image_tag=$CI_COMMIT_SHA environment=staging" \
        --extra-vars "service_name=$CI_PROJECT_NAME"
    # 完整测试验证
    - ansible-playbook -i inventory/staging.yml playbooks/integration-test.yml
  environment:
    name: staging
    url: https://$STAGING_HOST
  only:
    - tags
  when: manual
  allow_failure: false

# 生产环境部署
deploy-prod:
  stage: deploy-prod
  image: alpine:latest
  before_script:
    - apk add --no-cache curl ansible openssh
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
  script:
    # 生产部署前检查
    - ansible-playbook -i inventory/prod.yml playbooks/pre-deploy-check.yml
    
    # 蓝绿部署
    - |
      ansible-playbook -i inventory/prod.yml playbooks/blue-green-deploy.yml \
        --extra-vars "image_tag=$CI_COMMIT_SHA environment=prod" \
        --extra-vars "service_name=$CI_PROJECT_NAME"
    
    # 部署后验证
    - ansible-playbook -i inventory/prod.yml playbooks/post-deploy-verify.yml
  environment:
    name: production
    url: https://$PROD_HOST
  only:
    - tags
  when: manual
  allow_failure: false

# 环境清理
stop-dev:
  stage: deploy-dev
  image: alpine:latest
  script:
    - |
      ansible-playbook -i inventory/dev.yml playbooks/cleanup.yml \
        --extra-vars "service_name=$CI_PROJECT_NAME"
  environment:
    name: development
    action: stop
  when: manual
```

#### 前端项目自动化配置
```yaml
# .gitlab-ci.yml for Frontend
stages:
  - install
  - lint
  - test
  - build
  - deploy-dev
  - deploy-test
  - deploy-prod

cache:
  paths:
    - node_modules/
    - .yarn/cache

# 依赖安装
install-deps:
  stage: install
  image: node:18-alpine
  script:
    - yarn install --frozen-lockfile --cache-folder .yarn/cache
  artifacts:
    paths:
      - node_modules/
    expire_in: 1 hour

# 代码规范检查
lint-check:
  stage: lint
  image: node:18-alpine
  script:
    - yarn lint
    - yarn type-check
    - yarn format:check
  only:
    - merge_requests
    - main
    - develop

# 单元测试
unit-test:
  stage: test
  image: node:18-alpine
  script:
    - yarn test:unit --coverage --reporter=junit
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  artifacts:
    reports:
      junit: test-results.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
  only:
    - merge_requests
    - main
    - develop

# E2E测试
e2e-test:
  stage: test
  image: cypress/browsers:node18.12.0-chrome106-ff106
  services:
    - name: registry.company.com/business-service:latest
      alias: api-server
  script:
    - yarn cy:run --browser chrome
  artifacts:
    when: always
    paths:
      - cypress/videos/
      - cypress/screenshots/
    expire_in: 1 week
  only:
    - main
    - /^release\/.*$/

# 构建不同环境版本
.build-template: &build-template
  stage: build
  image: node:18-alpine
  script:
    - yarn build:$ENVIRONMENT
    - echo "BUILD_VERSION=$CI_COMMIT_SHA" > dist/version.txt
    - echo "BUILD_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> dist/version.txt
  artifacts:
    paths:
      - dist/
    expire_in: 1 hour

build-dev:
  <<: *build-template
  variables:
    ENVIRONMENT: dev
  only:
    - develop

build-test:
  <<: *build-template
  variables:
    ENVIRONMENT: test
  only:
    - main
    - /^release\/.*$/

build-prod:
  <<: *build-template
  variables:
    ENVIRONMENT: prod
  only:
    - tags

# 部署到CDN/Nginx
.deploy-template: &deploy-template
  image: alpine:latest
  before_script:
    - apk add --no-cache rsync openssh curl
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
  script:
    # 部署静态文件
    - rsync -avz --delete dist/ $DEPLOY_USER@$DEPLOY_HOST:$DEPLOY_PATH/$CI_PROJECT_NAME/
    
    # 更新Nginx配置
    - |
      ssh $DEPLOY_USER@$DEPLOY_HOST "
        sudo /opt/scripts/update-nginx-config.sh $CI_PROJECT_NAME $ENVIRONMENT
        sudo nginx -t && sudo nginx -s reload
      "
    
    # 健康检查
    - sleep 10
    - curl -f $DEPLOY_URL/health || exit 1

deploy-dev:
  <<: *deploy-template
  stage: deploy-dev
  variables:
    ENVIRONMENT: dev
    DEPLOY_HOST: $DEV_HOST
    DEPLOY_PATH: /var/www/dev
    DEPLOY_URL: https://$DEV_HOST
  environment:
    name: development
    url: https://$DEV_HOST
  dependencies:
    - build-dev
  only:
    - develop

deploy-test:
  <<: *deploy-template
  stage: deploy-test
  variables:
    ENVIRONMENT: test
    DEPLOY_HOST: $TEST_HOST
    DEPLOY_PATH: /var/www/test
    DEPLOY_URL: https://$TEST_HOST
  environment:
    name: testing
    url: https://$TEST_HOST
  dependencies:
    - build-test
  only:
    - main
    - /^release\/.*$/

deploy-prod:
  <<: *deploy-template
  stage: deploy-prod
  variables:
    ENVIRONMENT: prod
    DEPLOY_HOST: $PROD_HOST
    DEPLOY_PATH: /var/www/prod
    DEPLOY_URL: https://$PROD_HOST
  environment:
    name: production
    url: https://$PROD_HOST
  dependencies:
    - build-prod
  only:
    - tags
  when: manual
```

## 三、Nginx网关配置

### 3.1 网关架构设计

#### 网关功能定位

**核心功能：**
- **统一入口：** 所有外部请求的唯一入口点
- **路由分发：** 根据请求路径智能路由到后端服务
- **负载均衡：** 多实例服务的流量分发
- **安全防护：** SSL终结、请求限流、防护攻击
- **监控日志：** 访问日志、性能监控、异常告警

#### 网关分层设计
```
Nginx Gateway Architecture
├── 入口层 (Entry Layer)
│   ├── 域名解析 (DNS)
│   ├── SSL证书 (TLS)
│   └── CDN加速 (可选)
├── 网关层 (Gateway Layer)
│   ├── 主负载均衡器 (Primary LB)
│   ├── 备用负载均衡器 (Backup LB)
│   └── 健康检查 (Health Check)
├── 路由层 (Routing Layer)
│   ├── API网关 (/api/*)
│   ├── Web应用 (/app/*)
│   ├── 静态资源 (/static/*)
│   └── 管理后台 (/admin/*)
└── 后端层 (Backend Layer)
    ├── 业务服务集群
    ├── 管理服务集群
    ├── 文件存储服务
    └── 其他微服务
```

### 3.2 主配置文件设计

#### 核心网关配置
```nginx
# /etc/nginx/nginx.conf
user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

# 优化配置
worker_rlimit_nofile 65535;

events {
    worker_connections 4096;
    use epoll;
    multi_accept on;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;
    
    # 日志格式
    log_format main_json escape=json
    '{
        "time": "$time_iso8601",
        "remote_addr": "$remote_addr",
        "request_method": "$request_method",
        "request_uri": "$request_uri",
        "status": $status,
        "body_bytes_sent": $body_bytes_sent,
        "http_referer": "$http_referer",
        "http_user_agent": "$http_user_agent",
        "http_x_forwarded_for": "$http_x_forwarded_for",
        "request_time": $request_time,
        "upstream_response_time": "$upstream_response_time",
        "upstream_addr": "$upstream_addr"
    }';
    
    access_log /var/log/nginx/access.log main_json;
    
    # 性能优化
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    keepalive_requests 1000;
    
    # 压缩配置
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_comp_level 6;
    gzip_types
        text/plain
        text/css
        text/xml
        text/javascript
        application/json
        application/javascript
        application/xml+rss
        application/atom+xml
        image/svg+xml;
    
    # 缓冲区大小
    client_max_body_size 50m;
    client_body_buffer_size 128k;
    client_header_buffer_size 4k;
    large_client_header_buffers 4 16k;
    
    # 超时配置
    client_body_timeout 30s;
    client_header_timeout 30s;
    send_timeout 30s;
    
    # 限流配置
    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
    limit_req_zone $binary_remote_addr zone=login:10m rate=1r/s;
    limit_conn_zone $binary_remote_addr zone=conn:10m;
    
    # 包含其他配置文件
    include /etc/nginx/conf.d/*.conf;
    include /etc/nginx/sites-enabled/*;
}
```

### 3.3 环境特定配置

#### 开发环境网关配置
```nginx
# /etc/nginx/sites-available/dev.company.com
upstream dev_backend_api {
    least_conn;
    server 10.0.1.20:8080 weight=1 max_fails=3 fail_timeout=30s;
    server 10.0.1.21:8080 weight=1 max_fails=3 fail_timeout=30s;
    
    keepalive 32;
    keepalive_requests 100;
    keepalive_timeout 60s;
}

upstream dev_backend_admin {
    least_conn;
    server 10.0.1.22:8081 weight=1 max_fails=3 fail_timeout=30s;
    server 10.0.1.23:8081 weight=1 max_fails=3 fail_timeout=30s;
    
    keepalive 16;
}

server {
    listen 80;
    server_name dev.company.com;
    
    # 开发环境重定向到HTTPS（可选）
    # return 301 https://$server_name$request_uri;
    
    # 开发环境允许HTTP访问
    include /etc/nginx/includes/common-security.conf;
    include /etc/nginx/includes/dev-routes.conf;
}

server {
    listen 443 ssl http2;
    server_name dev.company.com;
    
    # SSL配置
    ssl_certificate /etc/nginx/ssl/dev.company.com.crt;
    ssl_certificate_key /etc/nginx/ssl/dev.company.com.key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers on;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
    
    # 安全头
    add_header X-Frame-Options SAMEORIGIN always;
    add_header X-Content-Type-Options nosniff always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy strict-origin-when-cross-origin always;
    
    # 开发环境特殊配置
    add_header X-Environment "Development" always;
    
    # 错误页面
    error_page 404 /404.html;
    error_page 500 502 503 504 /50x.html;
    
    # 日志配置
    access_log /var/log/nginx/dev_access.log main_json;
    error_log /var/log/nginx/dev_error.log;
    
    # 包含路由配置
    include /etc/nginx/includes/dev-routes.conf;
}
```

#### 生产环境网关配置
```nginx
# /etc/nginx/sites-available/company.com
upstream prod_backend_api {
    least_conn;
    server 10.0.3.20:8080 weight=2 max_fails=3 fail_timeout=30s;
    server 10.0.3.21:8080 weight=2 max_fails=3 fail_timeout=30s;
    server 10.0.3.22:8080 weight=2 max_fails=3 fail_timeout=30s;
    server 10.0.3.23:8080 weight=2 max_fails=3 fail_timeout=30s;
    
    keepalive 64;
    keepalive_requests 1000;
    keepalive_timeout 60s;
}

upstream prod_backend_admin {
    least_conn;
    server 10.0.3.24:8081 weight=1 max_fails=3 fail_timeout=30s;
    server 10.0.3.25:8081 weight=1 max_fails=3 fail_timeout=30s;
    
    keepalive 32;
}

# HTTP自动重定向到HTTPS
server {
    listen 80;
    server_name company.com www.company.com;
    
    # HSTS预加载
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
    
    return 301 https://company.com$request_uri;
}

server {
    listen 443 ssl http2;
    server_name www.company.com;
    
    # SSL配置
    ssl_certificate /etc/nginx/ssl/company.com.crt;
    ssl_certificate_key /etc/nginx/ssl/company.com.key;
    
    # 主域名重定向
    return 301 https://company.com$request_uri;
}

server {
    listen 443 ssl http2;
    server_name company.com;
    
    # 增强SSL配置
    ssl_certificate /etc/nginx/ssl/company.com.crt;
    ssl_certificate_key /etc/nginx/ssl/company.com.key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-CHACHA20-POLY1305;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:50m;
    ssl_session_timeout 1d;
    ssl_session_tickets off;
    
    # OCSP装订
    ssl_stapling on;
    ssl_stapling_verify on;
    
    # 安全头（生产环境更严格）
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
    add_header X-Frame-Options DENY always;
    add_header X-Content-Type-Options nosniff always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy strict-origin-when-cross-origin always;
    add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self';" always;
    
    # 隐藏服务器信息
    server_tokens off;
    
    # 日志配置
    access_log /var/log/nginx/prod_access.log main_json;
    error_log /var/log/nginx/prod_error.log warn;
    
    # 包含路由配置
    include /etc/nginx/includes/prod-routes.conf;
}
```

### 3.4 路由配置模块

#### API路由配置
```nginx
# /etc/nginx/includes/dev-routes.conf

# 健康检查端点（无需认证）
location = /health {
    access_log off;
    return 200 "healthy\n";
    add_header Content-Type text/plain;
}

# Nginx状态监控（仅内网）
location = /nginx_status {
    stub_status on;
    access_log off;
    allow 10.0.0.0/8;
    allow 172.16.0.0/12;
    allow 192.168.0.0/16;
    deny all;
}

# API接口代理
location /api/ {
    # 限流配置（开发环境相对宽松）
    limit_req zone=api burst=20 nodelay;
    limit_conn conn 10;
    
    # 代理配置
    proxy_pass http://dev_backend_api;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Request-ID $request_id;
    
    # 超时配置
    proxy_connect_timeout 10s;
    proxy_send_timeout 60s;
    proxy_read_timeout 60s;
    
    # 缓冲配置
    proxy_buffering on;
    proxy_buffer_size 8k;
    proxy_buffers 8 8k;
    proxy_busy_buffers_size 16k;
    
    # 错误处理
    proxy_next_upstream error timeout http_502 http_503 http_504;
    proxy_next_upstream_timeout 10s;
    proxy_next_upstream_tries 2;
    
    # 开发环境调试头
    add_header X-Upstream-Addr $upstream_addr always;
    add_header X-Response-Time $upstream_response_time always;
}

# 管理后台API
location /admin/api/ {
    # 更严格的限流
    limit_req zone=api burst=10 nodelay;
    limit_conn conn 5;
    
    # IP白名单（可选）
    # allow 10.0.1.0/24;  # 开发网段
    # deny all;
    
    proxy_pass http://dev_backend_admin/;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    
    proxy_connect_timeout 5s;
    proxy_send_timeout 30s;
    proxy_read_timeout 30s;
}

# 登录接口特殊限流
location /api/auth/login {
    limit_req zone=login burst=5 nodelay;
    
    proxy_pass http://dev_backend_api;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
}

# 文件上传接口
location /api/upload {
    client_max_body_size 100m;
    client_body_timeout 300s;
    
    proxy_pass http://dev_backend_api;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    
    proxy_request_buffering off;
    proxy_send_timeout 300s;
    proxy_read_timeout 300s;
}

# WebSocket支持
location /ws/ {
    proxy_pass http://dev_backend_api;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    
    proxy_read_timeout 3600s;
    proxy_send_timeout 3600s;
}

# 静态资源
location /static/ {
    root /var/www/dev;
    
    # 缓存配置
    location ~* \.(css|js|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
        expires 7d;
        add_header Cache-Control "public, immutable";
        add_header X-Cache-Status "HIT";
    }
    
    # 安全配置
    location ~* \.(php|jsp|asp|py|rb|sh|pl)$ {
        deny all;
    }
}

# 前端应用
location / {
    root /var/www/dev/frontend;
    index index.html;
    try_files $uri $uri/ /index.html;
    
    # SPA应用缓存策略
    location = /index.html {
        expires -1;
        add_header Cache-Control "no-cache, no-store, must-revalidate";
    }
    
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
        expires 30d;
        add_header Cache-Control "public, immutable";
    }
}

# 错误页面
location = /404.html {
    root /var/www/error-pages;
    internal;
}

location = /50x.html {
    root /var/www/error-pages;
    internal;
}
```

#### 生产环境路由配置
```nginx
# /etc/nginx/includes/prod-routes.conf

# 健康检查（仅内网）
location = /health {
    access_log off;
    allow 10.0.0.0/8;
    allow 172.16.0.0/12;
    deny all;
    return 200 "healthy\n";
    add_header Content-Type text/plain;
}

# 生产API接口（更严格的限流）
location /api/ {
    # 严格限流
    limit_req zone=api burst=10 nodelay;
    limit_conn conn 5;
    
    # 黑名单检查
    if ($http_user_agent ~* "(bot|crawler|spider|scraper)") {
        return 403;
    }
    
    # 防止SQL注入等攻击
    if ($request_uri ~* "(union|select|insert|delete|update|drop|create|alter)") {
        return 403;
    }
    
    proxy_pass http://prod_backend_api;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Request-ID $request_id;
    
    # 生产环境优化的超时
    proxy_connect_timeout 5s;
    proxy_send_timeout 30s;
    proxy_read_timeout 30s;
    
    # 隐藏后端信息
    proxy_hide_header X-Powered-By;
    proxy_hide_header Server;
    
    # 错误处理
    proxy_next_upstream error timeout http_502 http_503 http_504;
    proxy_next_upstream_timeout 5s;
    proxy_next_upstream_tries 3;
    
    # 不显示调试信息
    # add_header X-Upstream-Addr $upstream_addr always; # 生产环境不显示
}

# 管理后台（IP白名单）
location /admin/ {
    # 严格IP限制
    allow 10.0.3.0/24;    # 办公网段
    allow 1.2.3.4;        # VPN出口IP
    deny all;
    
    limit_req zone=api burst=5 nodelay;
    limit_conn conn 2;
    
    proxy_pass http://prod_backend_admin/;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
}

# 登录接口极严格限流
location /api/auth/login {
    limit_req zone=login burst=2 nodelay;
    
    proxy_pass http://prod_backend_api;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
}

# 静态资源（CDN加速）
location /static/ {
    root /var/www/prod;
    
    # 强缓存
    location ~* \.(css|js|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
        
        # 跨域配置（如果需要）
        add_header Access-Control-Allow-Origin "https://company.com";
    }
    
    # 安全检查
    location ~* \.(php|jsp|asp|py|rb|sh|pl|exe|bat)$ {
        deny all;
    }
}

# 前端应用
location / {
    root /var/www/prod/frontend;
    index index.html;
    try_files $uri $uri/ /index.html;
    
    # 主页面不缓存
    location = /index.html {
        expires -1;
        add_header Cache-Control "no-cache, no-store, must-revalidate";
        add_header Pragma "no-cache";
    }
    
    # 资源文件长期缓存
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
}

# 安全防护 - 禁止访问敏感文件
location ~* \.(htaccess|htpasswd|ini|log|sh|sql|conf)$ {
    deny all;
}

# 防止访问隐藏文件
location ~ /\. {
    deny all;
    access_log off;
    log_not_found off;
}
```

### 3.5 Nginx自动化管理

#### 配置管理脚本
```bash
#!/bin/bash
# scripts/nginx-manager.sh

set -e

# 配置变量
NGINX_CONFIG_DIR="/etc/nginx"
NGINX_SITES_AVAILABLE="$NGINX_CONFIG_DIR/sites-available"
NGINX_SITES_ENABLED="$NGINX_CONFIG_DIR/sites-enabled"
NGINX_INCLUDES="$NGINX_CONFIG_DIR/includes"
BACKUP_DIR="/opt/nginx-backups"

# 颜色输出
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log() { echo -e "${GREEN}[$(date +'%H:%M:%S')] $1${NC}"; }
warn() { echo -e "${YELLOW}[$(date +'%H:%M:%S')] $1${NC}"; }
error() { echo -e "${RED}[$(date +'%H:%M:%S')] $1${NC}"; exit 1; }

# 备份配置
backup_config() {
    local backup_file="$BACKUP_DIR/nginx-config-$(date +%Y%m%d-%H%M%S).tar.gz"
    
    mkdir -p "$BACKUP_DIR"
    
    log "备份Nginx配置到: $backup_file"
    tar -czf "$backup_file" -C "$NGINX_CONFIG_DIR" .
    
    # 保留最近10个备份
    ls -t "$BACKUP_DIR"/nginx-config-*.tar.gz | tail -n +11 | xargs -r rm
}

# 测试配置
test_config() {
    log "测试Nginx配置"
    
    if nginx -t; then
        log "配置测试通过"
        return 0
    else
        error "配置测试失败"
        return 1
    fi
}

# 重载配置
reload_nginx() {
    if test_config; then
        log "重新加载Nginx配置"
        systemctl reload nginx
        log "Nginx配置重载成功"
    else
        error "配置测试失败，取消重载"
    fi
}

# 启用站点
enable_site() {
    local site=$1
    
    if [[ ! -f "$NGINX_SITES_AVAILABLE/$site" ]]; then
        error "站点配置文件不存在: $NGINX_SITES_AVAILABLE/$site"
    fi
    
    log "启用站点: $site"
    ln -sf "$NGINX_SITES_AVAILABLE/$site" "$NGINX_SITES_ENABLED/$site"
    
    reload_nginx
}

# 禁用站点
disable_site() {
    local site=$1
    
    if [[ ! -L "$NGINX_SITES_ENABLED/$site" ]]; then
        warn "站点未启用: $site"
        return 0
    fi
    
    log "禁用站点: $site"
    rm "$NGINX_SITES_ENABLED/$site"
    
    reload_nginx
}

# 更新上游服务器
update_upstream() {
    local env=$1
    local service=$2
    local servers=$3
    
    local upstream_file="$NGINX_INCLUDES/${env}-${service}-upstream.conf"
    
    log "更新上游配置: $upstream_file"
    
    # 备份当前配置
    if [[ -f "$upstream_file" ]]; then
        cp "$upstream_file" "${upstream_file}.backup"
    fi
    
    # 生成新配置
    cat > "$upstream_file" << EOF
upstream ${env}_${service} {
    least_conn;
EOF
    
    # 添加服务器列表
    IFS=',' read -ra SERVER_ARRAY <<< "$servers"
    for server in "${SERVER_ARRAY[@]}"; do
        echo "    server $server weight=1 max_fails=3 fail_timeout=30s;" >> "$upstream_file"
    done
    
    cat >> "$upstream_file" << EOF
    
    keepalive 32;
    keepalive_requests 100;
    keepalive_timeout 60s;
}
EOF
    
    log "上游配置已更新"
    reload_nginx
}

# 查看状态
show_status() {
    log "Nginx服务状态"
    systemctl status nginx --no-pager
    
    echo
    log "启用的站点"
    ls -la "$NGINX_SITES_ENABLED"
    
    echo
    log "Nginx进程"
    ps aux | grep nginx
}

# 查看访问日志
show_access_logs() {
    local lines=${1:-100}
    local env=${2:-""}
    
    if [[ -n "$env" ]]; then
        log "查看 $env 环境访问日志 (最近 $lines 行)"
        tail -n "$lines" "/var/log/nginx/${env}_access.log" | jq -r '"\(.time) \(.remote_addr) \(.request_method) \(.request_uri) \(.status) \(.request_time)s"'
    else
        log "查看访问日志 (最近 $lines 行)"
        tail -n "$lines" /var/log/nginx/access.log
    fi
}

# 查看错误日志
show_error_logs() {
    local lines=${1:-50}
    
    log "查看错误日志 (最近 $lines 行)"
    tail -n "$lines" /var/log/nginx/error.log
}

# SSL证书更新
update_ssl() {
    local domain=$1
    
    if [[ -z "$domain" ]]; then
        error "请指定域名"
    fi
    
    log "更新SSL证书: $domain"
    
    # 使用Let's Encrypt自动更新（示例）
    if command -v certbot >/dev/null; then
        certbot renew --nginx --cert-name "$domain"
        log "SSL证书更新完成"
    else
        warn "certbot未安装，请手动更新SSL证书"
    fi
}

# 帮助信息
show_help() {
    cat << EOF
Nginx管理工具

用法: $0 <command> [options]

命令:
    backup                          备份当前配置
    test                           测试配置文件
    reload                         重新加载配置
    enable-site <site>             启用站点
    disable-site <site>            禁用站点
    update-upstream <env> <service> <servers>  更新上游服务器
    status                         查看服务状态
    access-logs [lines] [env]      查看访问日志
    error-logs [lines]             查看错误日志
    update-ssl <domain>            更新SSL证书
    
示例:
    $0 backup
    $0 enable-site dev.company.com
    $0 update-upstream dev api "10.0.1.20:8080,10.0.1.21:8080"
    $0 access-logs 200 prod
EOF
}

# 主函数
main() {
    local command=$1
    
    case "$command" in
        backup)
            backup_config
            ;;
        test)
            test_config
            ;;
        reload)
            reload_nginx
            ;;
        enable-site)
            enable_site "$2"
            ;;
        disable-site)
            disable_site "$2"
            ;;
        update-upstream)
            update_upstream "$2" "$3" "$4"
            ;;
        status)
            show_status
            ;;
        access-logs)
            show_access_logs "$2" "$3"
            ;;
        error-logs)
            show_error_logs "$2"
            ;;
        update-ssl)
            update_ssl "$2"
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            error "未知命令: $command\n使用 '$0 help' 查看帮助"
            ;;
    esac
}

# 执行主函数
main "$@"
```

#### Nginx配置自动化Ansible任务
```yaml
# playbooks/nginx-config.yml
---
- name: Configure Nginx Gateway
  hosts: webservers
  become: yes
  vars:
    nginx_user: nginx
    nginx_worker_processes: auto
    nginx_worker_connections: 4096
    
  tasks:
    - name: Install Nginx
      package:
        name: nginx
        state: present
        
    - name: Create Nginx directories
      file:
        path: "{{ item }}"
        state: directory
        owner: root
        group: root
        mode: '0755'
      loop:
        - /etc/nginx/includes
        - /var/log/nginx
        - /var/www/error-pages
        - /opt/nginx-backups
        
    - name: Generate main nginx.conf
      template:
        src: nginx.conf.j2
        dest: /etc/nginx/nginx.conf
        backup: yes
        owner: root
        group: root
        mode: '0644'
      notify: reload nginx
      
    - name: Generate site configurations
      template:
        src: "{{ item.src }}"
        dest: "/etc/nginx/sites-available/{{ item.dest }}"
        owner: root
        group: root
        mode: '0644'
      loop:
        - { src: "site-{{ environment }}.conf.j2", dest: "{{ domain }}" }
      notify: reload nginx
      
    - name: Generate route includes
      template:
        src: "{{ environment }}-routes.conf.j2"
        dest: "/etc/nginx/includes/{{ environment }}-routes.conf"
        owner: root
        group: root
        mode: '0644'
      notify: reload nginx
      
    - name: Enable site
      file:
        src: "/etc/nginx/sites-available/{{ domain }}"
        dest: "/etc/nginx/sites-enabled/{{ domain }}"
        state: link
      notify: reload nginx
      
    - name: Install management script
      copy:
        src: nginx-manager.sh
        dest: /usr/local/bin/nginx-manager
        owner: root
        group: root
        mode: '0755'
        
    - name: Start and enable Nginx
      systemd:
        name: nginx
        state: started
        enabled: yes
        
  handlers:
    - name: reload nginx
      systemd:
        name: nginx
        state: reloaded
```

## 四、Ansible自动化部署配置

### 3.1 Inventory环境配置

#### 环境清单配置
```yaml
# inventory/dev.yml
all:
  children:
    webservers:
      hosts:
        dev-web-01:
          ansible_host: 10.0.1.10
          ansible_user: deploy
        dev-web-02:
          ansible_host: 10.0.1.11
          ansible_user: deploy
      vars:
        environment: dev
        nginx_upstream_name: dev-backend
        
    appservers:
      hosts:
        dev-app-01:
          ansible_host: 10.0.1.20
          ansible_user: deploy
        dev-app-02:
          ansible_host: 10.0.1.21
          ansible_user: deploy
      vars:
        environment: dev
        app_port: 8080
        jvm_opts: "-Xms256m -Xmx512m"
        
    databases:
      hosts:
        dev-db-01:
          ansible_host: 10.0.1.30
          ansible_user: deploy
      vars:
        environment: dev
        mysql_port: 3306
        
  vars:
    domain: dev.company.com
    ssl_enabled: false
    log_level: DEBUG
    replicas: 1
```

```yaml
# inventory/prod.yml
all:
  children:
    webservers:
      hosts:
        prod-web-01:
          ansible_host: 10.0.3.10
          ansible_user: deploy
        prod-web-02:
          ansible_host: 10.0.3.11
          ansible_user: deploy
        prod-web-03:
          ansible_host: 10.0.3.12
          ansible_user: deploy
      vars:
        environment: prod
        nginx_upstream_name: prod-backend
        
    appservers:
      hosts:
        prod-app-01:
          ansible_host: 10.0.3.20
          ansible_user: deploy
        prod-app-02:
          ansible_host: 10.0.3.21
          ansible_user: deploy
        prod-app-03:
          ansible_host: 10.0.3.22
          ansible_user: deploy
        prod-app-04:
          ansible_host: 10.0.3.23
          ansible_user: deploy
      vars:
        environment: prod
        app_port: 8080
        jvm_opts: "-Xms1g -Xmx2g"
        
    databases:
      hosts:
        prod-db-01:
          ansible_host: 10.0.3.30
          ansible_user: deploy
        prod-db-02:
          ansible_host: 10.0.3.31
          ansible_user: deploy
      vars:
        environment: prod
        mysql_port: 3306
        
  vars:
    domain: company.com
    ssl_enabled: true
    log_level: INFO
    replicas: 2
```

### 3.2 部署Playbook

#### 主部署脚本
```yaml
# playbooks/deploy.yml
---
- name: Deploy Application
  hosts: all
  become: yes
  vars:
    app_name: "{{ service_name }}"
    app_version: "{{ image_tag }}"
    deploy_path: "/opt/apps/{{ app_name }}"
    
  tasks:
    - name: Create deployment directory
      file:
        path: "{{ deploy_path }}"
        state: directory
        owner: deploy
        group: deploy
        mode: '0755'

    - name: Generate docker-compose file
      template:
        src: docker-compose.yml.j2
        dest: "{{ deploy_path }}/docker-compose.yml"
        owner: deploy
        group: deploy
        mode: '0644'
      notify: restart application

    - name: Generate environment file
      template:
        src: app.env.j2
        dest: "{{ deploy_path }}/.env"
        owner: deploy
        group: deploy
        mode: '0600'
      notify: restart application

    - name: Pull latest images
      docker_image:
        name: "registry.company.com/{{ app_name }}:{{ app_version }}"
        source: pull
        force_source: yes

    - name: Start application
      docker_compose:
        project_src: "{{ deploy_path }}"
        state: present
        build: no
        recreate: smart
      register: deploy_result

    - name: Wait for application to be ready
      uri:
        url: "http://localhost:{{ app_port }}/actuator/health"
        method: GET
        status_code: 200
      retries: 30
      delay: 10
      when: app_port is defined

    - name: Update nginx upstream
      template:
        src: nginx-upstream.conf.j2
        dest: "/etc/nginx/conf.d/{{ app_name }}-upstream.conf"
        backup: yes
      notify: reload nginx
      when: inventory_hostname in groups['webservers']

  handlers:
    - name: restart application
      docker_compose:
        project_src: "{{ deploy_path }}"
        state: present
        recreate: always

    - name: reload nginx
      service:
        name: nginx
        state: reloaded
```

#### 蓝绿部署脚本
```yaml
# playbooks/blue-green-deploy.yml
---
- name: Blue-Green Deployment
  hosts: appservers
  become: yes
  vars:
    app_name: "{{ service_name }}"
    app_version: "{{ image_tag }}"
    deploy_path: "/opt/apps/{{ app_name }}"
    
  tasks:
    - name: Determine current environment
      shell: |
        if docker ps --format "table {{.Names}}" | grep -q "{{ app_name }}-blue"; then
          echo "green"
        else
          echo "blue"
        fi
      register: target_env
      
    - name: Set deployment variables
      set_fact:
        current_env: "{{ 'blue' if target_env.stdout == 'green' else 'green' }}"
        new_env: "{{ target_env.stdout }}"
        current_port: "{{ '8080' if target_env.stdout == 'green' else '8081' }}"
        new_port: "{{ '8081' if target_env.stdout == 'green' else '8080' }}"

    - name: Generate new environment compose file
      template:
        src: docker-compose-bg.yml.j2
        dest: "{{ deploy_path }}/docker-compose-{{ new_env }}.yml"
        owner: deploy
        group: deploy
      vars:
        env_suffix: "{{ new_env }}"
        app_port: "{{ new_port }}"

    - name: Start new environment
      docker_compose:
        project_src: "{{ deploy_path }}"
        files:
          - "docker-compose-{{ new_env }}.yml"
        state: present

    - name: Health check new environment
      uri:
        url: "http://localhost:{{ new_port }}/actuator/health"
        method: GET
        status_code: 200
      retries: 30
      delay: 10

    - name: Switch traffic to new environment
      template:
        src: nginx-upstream.conf.j2
        dest: "/etc/nginx/conf.d/{{ app_name }}-upstream.conf"
      vars:
        backend_port: "{{ new_port }}"
      delegate_to: "{{ item }}"
      loop: "{{ groups['webservers'] }}"
      notify: reload nginx

    - name: Wait for traffic switch
      pause:
        seconds: 30

    - name: Stop old environment
      docker_compose:
        project_src: "{{ deploy_path }}"
        files:
          - "docker-compose-{{ current_env }}.yml"
        state: absent

  handlers:
    - name: reload nginx
      service:
        name: nginx
        state: reloaded
      delegate_to: "{{ inventory_hostname }}"
```

### 3.3 配置模板

#### Docker Compose模板
```yaml
# templates/docker-compose.yml.j2
version: '3.8'

services:
  {{ app_name }}:
    image: registry.company.com/{{ app_name }}:{{ app_version }}
    container_name: {{ app_name }}{% if env_suffix is defined %}-{{ env_suffix }}{% endif %}
    restart: unless-stopped
    ports:
      - "{{ app_port }}:8080"
    environment:
      - SPRING_PROFILES_ACTIVE={{ environment }}
      - JVM_OPTS={{ jvm_opts }}
      - DB_HOST={{ groups['databases'][0] }}
      - REDIS_HOST=redis
    env_file:
      - .env
    volumes:
      - app_logs:/app/logs
      - app_data:/app/data
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    logging:
      driver: "json-file"
      options:
        max-size: "100m"
        max-file: "3"

  redis:
    image: redis:7-alpine
    container_name: {{ app_name }}-redis{% if env_suffix is defined %}-{{ env_suffix }}{% endif %}
    restart: unless-stopped
    command: redis-server --requirepass ${REDIS_PASSWORD}
    volumes:
      - redis_data:/data
    networks:
      - app-network

networks:
  app-network:
    driver: bridge

volumes:
  app_logs:
    driver: local
  app_data:
    driver: local
  redis_data:
    driver: local
```

#### Nginx配置模板
```nginx
# templates/nginx-upstream.conf.j2
upstream {{ nginx_upstream_name }} {
    least_conn;
    {% for host in groups['appservers'] %}
    server {{ hostvars[host]['ansible_host'] }}:{{ backend_port | default(app_port) }} weight=1 max_fails=3 fail_timeout=30s;
    {% endfor %}
    
    # 健康检查
    keepalive 32;
    keepalive_requests 100;
    keepalive_timeout 60s;
}

server {
    listen 80;
    {% if ssl_enabled %}
    listen 443 ssl http2;
    {% endif %}
    server_name {{ domain }};

    {% if ssl_enabled %}
    ssl_certificate /etc/nginx/ssl/{{ domain }}.crt;
    ssl_certificate_key /etc/nginx/ssl/{{ domain }}.key;
    {% endif %}

    # 安全头
    add_header X-Frame-Options DENY;
    add_header X-Content-Type-Options nosniff;
    add_header X-XSS-Protection "1; mode=block";

    # 日志配置
    access_log /var/log/nginx/{{ app_name }}_access.log combined;
    error_log /var/log/nginx/{{ app_name }}_error.log warn;

    # 健康检查端点
    location /health {
        access_log off;
        return 200 "healthy\n";
    }

    # API代理
    location /api/ {
        proxy_pass http://{{ nginx_upstream_name }}/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # 超时配置
        proxy_connect_timeout 30s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
        
        # 缓冲配置
        proxy_buffering on;
        proxy_buffer_size 4k;
        proxy_buffers 8 4k;
    }

    # 静态文件
    location / {
        root /var/www/{{ environment }}/{{ app_name }};
        index index.html;
        try_files $uri $uri/ /index.html;
        
        # 缓存配置
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
        }
    }
}
```

## 四、环境管理脚本

### 4.1 环境管理工具

#### 部署管理脚本
```bash
#!/bin/bash
# scripts/deploy-manager.sh

set -e

# 配置变量
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
ENVIRONMENTS=("dev" "test" "staging" "prod")

# 颜色输出
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log() { echo -e "${GREEN}[$(date +'%H:%M:%S')] $1${NC}"; }
warn() { echo -e "${YELLOW}[$(date +'%H:%M:%S')] $1${NC}"; }
error() { echo -e "${RED}[$(date +'%H:%M:%S')] $1${NC}"; exit 1; }
info() { echo -e "${BLUE}[$(date +'%H:%M:%S')] $1${NC}"; }

# 显示帮助信息
show_help() {
    cat << EOF
部署管理工具

用法: $0 <command> [options]

命令:
    deploy <env> <service> [version]    部署服务到指定环境
    rollback <env> <service> [version]  回滚服务到指定版本
    status <env> [service]              查看环境状态
    logs <env> <service> [lines]        查看服务日志
    scale <env> <service> <replicas>    扩缩容服务
    restart <env> <service>             重启服务
    cleanup <env>                       清理环境
    list-versions <service>             列出服务的所有版本

环境: ${ENVIRONMENTS[*]}

示例:
    $0 deploy dev business-service v1.2.3
    $0 rollback prod business-service v1.2.2
    $0 status test
    $0 logs prod business-service 100
    $0 scale prod business-service 3
EOF
}

# 验证环境
validate_environment() {
    local env=$1
    if [[ ! " ${ENVIRONMENTS[@]} " =~ " ${env} " ]]; then
        error "无效的环境: $env. 可用环境: ${ENVIRONMENTS[*]}"
    fi
}

# 验证服务
validate_service() {
    local service=$1
    local services_file="$PROJECT_ROOT/config/services.yml"
    
    if [[ ! -f "$services_file" ]]; then
        error "服务配置文件不存在: $services_file"
    fi
    
    if ! grep -q "^$service:" "$services_file"; then
        error "无效的服务: $service"
    fi
}

# 获取当前部署版本
get_current_version() {
    local env=$1
    local service=$2
    
    ansible -i "inventory/${env}.yml" appservers -m shell \
        -a "docker ps --format 'table {{.Image}}' | grep $service | head -1 | cut -d':' -f2" \
        2>/dev/null | grep -v "CHANGED" | tail -1 || echo "unknown"
}

# 部署服务
deploy_service() {
    local env=$1
    local service=$2
    local version=${3:-latest}
    
    validate_environment "$env"
    validate_service "$service"
    
    log "开始部署 $service:$version 到 $env 环境"
    
    # 记录部署信息
    local deploy_info="$PROJECT_ROOT/.deploy/${env}-${service}.info"
    mkdir -p "$(dirname "$deploy_info")"
    
    # 备份当前版本信息
    local current_version=$(get_current_version "$env" "$service")
    echo "PREVIOUS_VERSION=$current_version" > "$deploy_info"
    echo "DEPLOY_VERSION=$version" >> "$deploy_info"
    echo "DEPLOY_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> "$deploy_info"
    echo "DEPLOY_USER=$(whoami)" >> "$deploy_info"
    
    # 执行部署
    if ansible-playbook -i "inventory/${env}.yml" playbooks/deploy.yml \
        --extra-vars "service_name=$service image_tag=$version environment=$env" \
        --timeout 300; then
        
        log "部署成功: $service:$version -> $env"
        
        # 健康检查
        info "执行部署后健康检查..."
        if ansible-playbook -i "inventory/${env}.yml" playbooks/health-check.yml \
            --extra-vars "service_name=$service"; then
            log "健康检查通过"
        else
            warn "健康检查失败，请手动验证服务状态"
        fi
        
    else
        error "部署失败: $service:$version -> $env"
    fi
}

# 回滚服务
rollback_service() {
    local env=$1
    local service=$2
    local version=$3
    
    validate_environment "$env"
    validate_service "$service"
    
    local deploy_info="$PROJECT_ROOT/.deploy/${env}-${service}.info"
    
    # 如果没有指定版本，使用上一个版本
    if [[ -z "$version" ]]; then
        if [[ -f "$deploy_info" ]]; then
            version=$(grep "PREVIOUS_VERSION=" "$deploy_info" | cut -d'=' -f2)
        fi
        
        if [[ -z "$version" || "$version" == "unknown" ]]; then
            error "无法确定回滚版本，请手动指定版本"
        fi
    fi
    
    warn "准备回滚 $service 从当前版本到 $version 在 $env 环境"
    read -p "确认回滚? (y/N): " -n 1 -r
    echo
    
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        log "开始回滚 $service:$version 在 $env 环境"
        deploy_service "$env" "$service" "$version"
    else
        info "回滚已取消"
    fi
}

# 查看环境状态
show_status() {
    local env=$1
    local service=$2
    
    validate_environment "$env"
    
    log "查看 $env 环境状态"
    
    if [[ -n "$service" ]]; then
        validate_service "$service"
        ansible -i "inventory/${env}.yml" appservers -m shell \
            -a "docker ps --filter name=$service --format 'table {{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}'"
    else
        ansible -i "inventory/${env}.yml" all -m shell \
            -a "docker ps --format 'table {{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}'"
    fi
}

# 查看服务日志
show_logs() {
    local env=$1
    local service=$2
    local lines=${3:-100}
    
    validate_environment "$env"
    validate_service "$service"
    
    log "查看 $service 在 $env 环境的日志 (最近${lines}行)"
    
    ansible -i "inventory/${env}.yml" appservers -m shell \
        -a "docker logs --tail $lines $service"
}

# 扩缩容服务
scale_service() {
    local env=$1
    local service=$2
    local replicas=$3
    
    validate_environment "$env"
    validate_service "$service"
    
    if [[ ! "$replicas" =~ ^[0-9]+$ ]]; then
        error "副本数必须是数字: $replicas"
    fi
    
    log "扩缩容 $service 到 $replicas 个副本在 $env 环境"
    
    ansible-playbook -i "inventory/${env}.yml" playbooks/scale.yml \
        --extra-vars "service_name=$service replicas=$replicas"
}

# 重启服务
restart_service() {
    local env=$1
    local service=$2
    
    validate_environment "$env"
    validate_service "$service"
    
    warn "准备重启 $service 在 $env 环境"
    read -p "确认重启? (y/N): " -n 1 -r
    echo
    
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        log "重启 $service 在 $env 环境"
        ansible -i "inventory/${env}.yml" appservers -m shell \
            -a "docker restart $service"
    else
        info "重启已取消"
    fi
}

# 清理环境
cleanup_environment() {
    local env=$1
    
    validate_environment "$env"
    
    warn "准备清理 $env 环境 (停止所有容器并清理未使用的镜像)"
    read -p "确认清理? (y/N): " -n 1 -r
    echo
    
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        log "清理 $env 环境"
        ansible-playbook -i "inventory/${env}.yml" playbooks/cleanup.yml
    else
        info "清理已取消"
    fi
}

# 列出服务版本
list_versions() {
    local service=$1
    
    validate_service "$service"
    
    log "列出 $service 的可用版本"
    
    # 从镜像仓库获取版本列表
    curl -s "https://registry.company.com/v2/$service/tags/list" | \
        jq -r '.tags[]' | sort -V | tail -20
}

# 主函数
main() {
    local command=$1
    
    case "$command" in
        deploy)
            deploy_service "${@:2}"
            ;;
        rollback)
            rollback_service "${@:2}"
            ;;
        status)
            show_status "${@:2}"
            ;;
        logs)
            show_logs "${@:2}"
            ;;
        scale)
            scale_service "${@:2}"
            ;;
        restart)
            restart_service "${@:2}"
            ;;
        cleanup)
            cleanup_environment "${@:2}"
            ;;
        list-versions)
            list_versions "${@:2}"
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            error "未知命令: $command\n使用 '$0 help' 查看帮助"
            ;;
    esac
}

# 执行主函数
main "$@"
```

### 4.2 环境监控脚本

#### 健康检查脚本
```bash
#!/bin/bash
# scripts/health-monitor.sh

# 环境健康监控脚本
ENVIRONMENTS=("dev" "test" "staging" "prod")
SERVICES=("business-service" "admin-service" "web-frontend")
ALERT_WEBHOOK="https://hooks.dingtalk.com/xxx"

check_service_health() {
    local env=$1
    local service=$2
    
    local health_url="https://${env}.company.com/api/actuator/health"
    
    if curl -sf --max-time 10 "$health_url" > /dev/null; then
        return 0
    else
        return 1
    fi
}

send_alert() {
    local message=$1
    
    curl -X POST "$ALERT_WEBHOOK" \
        -H "Content-Type: application/json" \
        -d "{\"msgtype\": \"text\", \"text\": {\"content\": \"$message\"}}"
}

monitor_environments() {
    for env in "${ENVIRONMENTS[@]}"; do
        for service in "${SERVICES[@]}"; do
            if ! check_service_health "$env" "$service"; then
                send_alert "⚠️ 服务异常: $service 在 $env 环境不可用"
            fi
        done
    done
}

# 定时监控
while true; do
    monitor_environments
    sleep 300  # 5分钟检查一次
done
```

## 五、实施时间计划

### 5.1 自动化部署实施计划

| 时间 | 工作内容 | 交付物 | 验收标准 |
|------|----------|---------|----------|
| 第1周 | GitLab CI/CD基础配置、Runner部署 | CI/CD基础环境 | 流水线正常运行 |
| 第2周 | Ansible环境配置、部署脚本开发 | 自动化部署脚本 | 单环境部署成功 |
| 第3周 | 多环境配置、蓝绿部署实现 | 完整部署体系 | 多环境部署成功 |
| 第4周 | 监控集成、管理工具开发 | 运维管理工具 | 部署监控可用 |

### 5.2 关键里程碑

- **第1周末：** CI/CD流水线能够自动构建和测试
- **第2周末：** 单环境自动化部署成功
- **第3周末：** 多环境部署体系完全自动化，Nginx网关配置完成
- **第4周末：** 完整的自动化运维体系交付使用，包括网关管理和监控

### 5.3 网关实施重点

**安全性：**
- SSL/TLS加密传输
- 请求限流和防护
- IP白名单和黑名单
- 安全头配置

**性能优化：**
- 负载均衡算法选择
- 连接池和缓存配置
- 静态资源优化
- 压缩和缓存策略

**监控运维：**
- 访问日志分析
- 性能监控告警
- 自动化配置管理
- 故障快速定位
